request
   setAttribute()作用域仅限于一次请求

request.setAttribute("mess","**");

doUserCreate.jsp
    注册成功--》index.jsp   重定向
    注册失败--》userCreate.jsp 转发

转发：服务器内部自动完成了跳转，服务器行为
       无形中延长了request作用域
    ---》doUserCreate.jsp
    --》doUserCreate.jsp--》userCreate.jsp


page:this  作用域仅限于当前页面


1、session：setAttribute()作用域是一次会话
会话：一个会话就是浏览器和服务器之间的一次通话
      会话可以在多次请求中保存和使用数据


服务器端使用的记录客户端状态的机制--sessionId  每一个session有一个唯一的sessionid

session.getId()

session是单用户、多页面可共享的   session保存在服务器端的

2 session的清除与过期


3 cookie:跟踪用户的整个会话
cookie通过在客户端记录信息
  给客户端发送一个通行证，每一个客户一个
cookie本质是文本信息

//设置路径
cookie.setPath("/");

4 cookie禁用后，session是否能使用（摘录网络内容，供大家参考）
URL重写
表单提交隐藏域

cookie禁用后，session能否使用的问题
sessionid是存储在cookie中的，解决方案如下：
Session URL重写，保证在客户端禁用或不支持COOKIE时，仍然可以使用Session

session机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。

当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个cookie的名字都是类似于 SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。 经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如：

<form name=”"testform”" action=”"/xxx”"> <input type=”"hidden”" name=”"jsessionid”" value=”"ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764″”> <input type=”"text”"> </form>

URL重写：

http://www.test.com/test;jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764





application：setAttribute()作用域？